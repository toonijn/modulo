doctype html
html
  head
    link(rel="stylesheet" href="/node_modules/reveal.js/dist/reveal.css")
    link(rel="stylesheet" href="/node_modules/highlight.js/styles/vs.css")
    link(rel="stylesheet" href="theme.scss")
  body
    .reveal
      .slides
        section
          h1 Table Of Content
          ul
            li background
              li about me
              li why I care about modulo
              li design goals (correctness, performance, easy to use), non-goals (easy to understand, small moduli, primes, perfect)
            li Modulo known at compile time
              ul
                li member type
                li operator+,-* with adl
                li something about operator/?
                li constructor
            li Unknown modulus
              ul
                li class design (member type, where to store modulus)
                li dependent types
                li detour about assume
                li __int128, umul128

        section
          h1 Design goals
          .row
            .col
              h2 Goals
              ul
                li Correctness
                li Easy to use
                li Performance
            .col
              h2 Non-goals
              ul
                li Easy to understand
                li Mathematical optimizations
                li Perfection

        section
          h1 Design goals
          h2 Easy to use
          .row
            .col
              h3 constexpr modulus
              :code
                using Mod = Modulo<17>;
            .col
              h3 run-time modulus
              :code
                // Something magical to get a Mod type
          h3 Usage
          :code
            auto a = Mod(3);
            a -= 2;
            auto b = 3 + a * 7
            a += a * b;
        section
          h1 First compile-time design
          include:code code/ct_naive.cpp
          .img.fragment(style="background: white; padding: 10px")
            include code/precedence.pug
        section
          h1 Compile-time datatype
          :code
            template<[...] modulus>
            struct Modulo {
              using ValueType = [...];
              ValueType value;
            }
          ul
            li What should #[:code(inline, subtle) ValueType] be?
              ul
                li Signedness?
                li #[:code(inline, subtle) value] needs to fit.
                  ul
                    li Does #[:code(inline, subtle) modulus] need to fit?
                    li Does #[:code(inline, subtle) value + value] need to fit?
                    li Does #[:code(inline, subtle) value * value] need to fit?
                li Do we care for #[:code(inline, subtle) __uint128]?
        section
          h1 Compile-time datatype
          include:code(compile="ct-datatype-output") code/ct_datatype.cpp
          .compiler-output
            pre#ct-datatype-output

          .fragment.img(style="padding: 30px; bottom: auto; top: 60px;")
            h2 Trade-offs

            ul
              li Storage
              li Caching 
              li Aritmetic speed
              li Vectorization
              li Unaligned loads
              li Even larger moduli
            p Benchmark it!

        section
          h1 Compile-time operators
          .row
            .col
              :code
                using Mod = Modulo<17>;
                Mod a{7};
            .col
              :code
                Mod a{7};
                a += 3;
                a *= -a;
            .col
              :code
                Mod a{7};
                Mod b{4};
                auto c = b - (a + 3) * 7;
          .row
            .col
              ul
                li Which operators?
                  ul
                    li #[:code(inline, subtle) operator+], #[:code(inline, subtle) operator-], #[:code(inline, subtle) operator*], #[:code(inline, subtle) operator/]
                    li #[:code(inline, subtle) operator+=], #[:code(inline, subtle) operator-=], #[:code(inline, subtle) operator*=], #[:code(inline, subtle) operator/=]
                    li #[:code(inline, subtle) operator+()], #[:code(inline, subtle) operator-()]
                    li #[:code(inline, subtle) operator++()], #[:code(inline, subtle) operator--()], #[:code(inline, subtle) operator++(int)], #[:code(inline, subtle) operator--(int)]
                    li #[:code(inline, subtle) operator&lt;=&gt;], #[:code(inline, subtle) operator==]
            .col
              ul
                li What about assignment operators?
                li What about conversion operators?
                  ul
                    li #[:code(inline, subtle) operator int()]
                    li #[:code(inline, subtle) operator bool()]
                li Can we reuse code between e.g. #[:code(inline, subtle) operator+] and #[:code(inline, subtle) operator+=]?
                li Can we default some operators?
                li Stream operators #[:code(inline, subtle) operator&lt;&lt;()], #[:code(inline, subtle) operator&gt;&gt;()]?
        section
          h1 Compile-time operators
          include:code(compile="ct-operators-output") code/ct_operators.cpp
          .compiler-output
            pre#ct-operators-output 
        section
          h1 Does this break everything?
          :code
            struct Modulo {

              template<typename Lhs, typename Rhs>
              friend Modulo operator+(Lhs&& lhs, Rhs&& rhs) {
                // ...
              }
            };

          blockquote
            | A name first declared in a friend declaration within a class or class template X becomes a member of the innermost enclosing namespace of X, but is not visible for lookup (except argument-dependent lookup that considers X) unless a matching declaration at namespace scope is provided [...].
            a.cite(
              href="https://en.cppreference.com/w/cpp/language/friend#Notes"
            ) cppreference.com/w/cpp/language/friend#Notes

        section
          h1 Aside: argument-dependent lookup (ADL)
          .row
            .col
              :code
                namespace ns1 {
                  struct A {};

                  void f(A) {}
                }

                namespace ns2 {
                  void g(ns1::A) {}
                }

                int main() {
                  ns1::A a;
                  f(a); // f will be found
                  g(a); // g will not
                }
            .col
              :code
                namespace ns1 {
                  struct A {};

                  void swap(A&, A&) { //... }
                }

                template<typename T>
                void f(T a, T b) {
                  using std::swap;
                  swap(a, b); // std::swap or ADL will find ns1::swap
                }

              :code
                int main() {
                  std::cout << "Foo " << 42 << std::endl;
                }


    script(src="index.js" type="module")
