doctype html
html
  head
    link(rel="stylesheet" href="/node_modules/reveal.js/dist/reveal.css")
    link(rel="stylesheet" href="/node_modules/highlight.js/styles/vs.css")
    link(rel="stylesheet" href="theme.scss")
  body
    .reveal
      .slides
        section
          h1 Table Of Content
          ul
            li background
              li about me
              li why I care about modulo
              li design goals (correctness, performance, easy to use), non-goals (easy to understand, small moduli, primes, perfect)
            li Modulo known at compile time
              ul
                li member type
                li operator+,-* with adl
                li something about operator/?
                li constructor
            li Unknown modulus
              ul
                li class design (member type, where to store modulus)
                li dependent types
                li detour about assume
                li __int128, umul128

        section
          h1 Design goals
          .row
            .col
              h2 Goals
              ul
                li Correctness
                li Easy to use
                li Performance
            .col
              h2 Non-goals
              ul
                li Easy to understand
                li Mathematical optimizations
                li Perfection

        section
          h1 Design goals
          h2 Easy to use
          .row
            .col
              h3 constexpr modulus
              :code
                using Mod = Modulo<17>;
            .col
              h3 run-time modulus
              :code
                // Something magical to get a Mod type
          h3 Usage
          :code
            auto a = Mod(3);
            a -= 2;
            auto b = 3 + a * 7
            a += a * b;
        section
          h1 Known modulus, first design
          include:code code/ct_naive.cpp
          .img.fragment(style="background: white; padding: 10px")
            include code/precedence.pug
        section
          h1 General datatype
          :code
            template<[...] modulus>
            struct Modulo {
              using ValueType = [...];
              ValueType value;
            }
          ul
            li What should #[:code(inline, subtle) ValueType] be?
              ul
                li Signedness?
                li #[:code(inline, subtle) value] needs to fit.
                  ul
                    li Does #[:code(inline, subtle) modulus] need to fit?
                    li Does #[:code(inline, subtle) value + value] need to fit?
                    li Does #[:code(inline, subtle) value * value] need to fit?
                li Do we care for #[:code(inline, subtle) __uint128]?
        section
          h1 General datatype
          include:code(compile="ct-datatype-output") code/ct_datatype.cpp
          .compiler-output
            pre#ct-datatype-output

          .fragment.img(style="padding: 30px; bottom: auto; top: 60px;")
            h2 Trade-offs

            ul
              li Storage
              li Caching 
              li Aritmetic speed
              li Vectorization
              li Unaligned loads
              li Even larger moduli
            p Run benchmarks!

        section
          h1 Operator overloading
          .row
            .col
              :code
                using Mod = Modulo<17>;
                Mod a{7};
            .col
              :code
                Mod a{7};
                a += 3;
                a *= -a;
            .col
              :code
                Mod a{7};
                Mod b{4};
                auto c = b - (a + 3) * 7;
          .row
            .col
              ul
                li Which operators?
                  ul
                    li #[:code(inline, subtle) operator+], #[:code(inline, subtle) operator-], #[:code(inline, subtle) operator*], #[:code(inline, subtle) operator/]
                    li #[:code(inline, subtle) operator+=], #[:code(inline, subtle) operator-=], #[:code(inline, subtle) operator*=], #[:code(inline, subtle) operator/=]
                    li #[:code(inline, subtle) operator+()], #[:code(inline, subtle) operator-()]
                    li #[:code(inline, subtle) operator++()], #[:code(inline, subtle) operator--()], #[:code(inline, subtle) operator++(int)], #[:code(inline, subtle) operator--(int)]
                    li #[:code(inline, subtle) operator&lt;=&gt;], #[:code(inline, subtle) operator==]
            .col
              ul
                li What about assignment operators?
                li What about conversion operators?
                  ul
                    li #[:code(inline, subtle) operator int()]
                    li #[:code(inline, subtle) operator bool()]
                li Can we reuse code between e.g. #[:code(inline, subtle) operator+] and #[:code(inline, subtle) operator+=]?
                li Can we default some operators?
                li Stream operators #[:code(inline, subtle) operator&lt;&lt;()], #[:code(inline, subtle) operator&gt;&gt;()]?
        section
          h1 operator==
          include:code code/ct_compare.cpp
        section 
          h1 Aside: value categories
          p Intuitively:
          .row
            .col
              p value
              :code
                T
                T const
              p "Use your own copy!"
            .col
              p lvalue reference
              :code
                T&
                T const&
              p "You can borrow my value, but I need it back."
            .col
              p rvalue reference
              :code
                T&&
                T const&&
              p "Here is my value, I don't care about it anymore."
          br
          p Perfect forwarding with #[:code(inline, subtle) std::forward] and #[:code(inline, subtle) decltype(auto)]
          :code
            template<typename T>
            decltype(auto) f(T&& t) {
              return g(std::forward<T>(t));
            }
        section
          h1 Aritmetic operators (1)
          include:code(compile="ct_aritmetic_operators_1") code/ct_aritmetic_operators_1.cpp
          .compiler-output
            pre#ct_aritmetic_operators_1
        section
          h1 Aritmetic operators (2)
          include:code(compile="ct_aritmetic_operators_2") code/ct_aritmetic_operators_2.cpp
          .compiler-output
            pre#ct_aritmetic_operators_2
        section
          h1 Does this break everything?
          :code
            struct Modulo {

              template<typename Lhs, typename Rhs>
              friend Modulo operator+(Lhs&& lhs, Rhs&& rhs) {
                // ...
              }
            };

          blockquote
            | A name first declared in a friend declaration within a class or class template X becomes a member of the innermost enclosing namespace of X, but is not visible for lookup (except argument-dependent lookup that considers X) unless a matching declaration at namespace scope is provided [...].
            a.cite(
              href="https://en.cppreference.com/w/cpp/language/friend#Notes"
            ) cppreference.com/w/cpp/language/friend#Notes
        section
          h1 Aside: argument-dependent lookup (ADL)
          .row
            .col
              :code
                namespace ns1 {
                  struct A {};

                  void f(A) {}
                }

                namespace ns2 {
                  void g(ns1::A) {}
                }

                int main() {
                  ns1::A a;
                  f(a); // f will be found
                  g(a); // g will not
                }
            .col
              :code
                namespace ns1 {
                  struct A {};

                  void swap(A&, A&) { //... }
                }

                template<typename T>
                void f(T a, T b) {
                  using std::swap;
                  swap(a, b); // std::swap or ADL will find ns1::swap
                }

              :code
                int main() {
                  std::cout << "Foo " << 42 << std::endl;
                }
        section
          h1 operator*
          .row
            .col
              include:code(compile="ct_product_simple") code/ct_product_simple.cpp
            .col.compiler-col
              pre#ct_product_simple(data-assembly)
        section
          h1 operator*
          .row
            .col
              include:code(compile="ct_product") code/ct_product.cpp
            .col.compiler-col
              pre#ct_product(data-assembly)
        section
          h1 Aside: mul and div
          p TODO: Compiler explorer's analysis
        section
          h1 The constructor(s)

          h2 Let's review!
          :code
            template<std::uint64_t modulus_>
            struct Modulo {
              using ValueType = [...];
              constexpr ValueType modulus(modulus_);
              ValueType value;

              template<typename V>
              Modulo(V raw_value)
                : value(raw_value % modulus_) {}
            }
          .fragment
            ul
              li Should we avoid the implicit one-argument constructor?
              li Could it be #[:code(inline, subtle) constexpr]?
              li What about the copy and move constructor?
              li Can the constructor as a template be improved?
              li Are the arithmetic conversions correct in #[i all] cases?
        section
          h1 The constructor(s)
          :code
            // TODO
        section
          h1 Let's recap
          p Known modulus
          ul
            li Member type
            li Constructors
            li Operators
        section
          h1 Run-time modulus
          h2 What should #[:code(inline, subtle) Mod] be?
          :code
            // Something magical to get a Mod type
            auto a = Mod(3);
            a -= 2;
            auto b = 3 + a * 7
            a += a * b;
          ul
            li Could it dependent on requested modulus?
            li Should it store the modulus?
            li What should the value type be?
            li How do we choose it at runtime?
        section
          h1 Aside: dependent type

          blockquote
            | In computer science and logic, a dependent type is a type whose definition depends on a value. It is an overlapping feature of type theory and type systems. [...]
            br
            | [A common example of dependent types are dependent functions.]
            | The return type of a dependent function may depend on the value (not just type) of one of its arguments.
            | For instance, a function that takes a positive integer #[:code(inline, subtle) n] may return an array of length #[:code(inline, subtle) n], where the array length is part of the type of the array.
            a.cite(
              href="https://en.wikipedia.org/wiki/Dependent_type"
            ) en.wikipedia.org/wiki/Dependent_type
          :code
            // Fictional example
            auto array_of_length(std::size_t n) -> std::array<double, n> {
              // ...
            }
        section
          h1 Aside: dependent type
          blockquote
            | In computer science and logic, a dependent type is a type whose definition depends on a value.
            a.cite(
              href="https://en.wikipedia.org/wiki/Dependent_type"
            ) en.wikipedia.org/wiki/Dependent_type

          br
          :code
            std::variant<int, double> v = get_a_variant_from_somewhere();

            std::visit([](auto&& arg) {
              std::cout << arg << std::endl;
            }, v);

          div The #[i value] of #[:code(inline, subtle) v] determines what the #[i type] of #[:code(inline, subtle) arg] will be.
        section 
          h1 Type dependent on modulus

          p Since C++20 we can write:

          :code
            modulo(17, []<typename Mod>() {
              auto a = Mod(3);
              a -= 8;
              std::cout << a << std::endl;
            });

          p or

          :code
            int modulus;
            std::cout >> modulus;
            bool is_special = modulo(modulus, []<typename Mod>() {
              auto a = Mod(3);
              a -= 8 * a;
              return a == -1;
            });
          br
          div But, what happens in #[:code(inline, subtle) modulo(auto modulus, auto lambda)]?
    script(src="index.js" type="module")
